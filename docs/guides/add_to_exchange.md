# Add EVER to your Exchange

## Introduction

This document describes the various ways to accomplish the most important tasks of running a crypto exchange that supports EVER.

There are a few different ways to accomplish the necessary tasks:

* Blockchain access may be set up either through the [Evercloud](https://docs.everos.dev/evernode-platform/products/evercloud/get-started) or through your own  node - the [DApp server](https://docs.everos.dev/evernode-platform/products/dapp-server-ds).
* Deposit account management can be accomplished either through the [everdev](https://docs.everos.dev/everdev/) command line tool or integrate into your backend with  EVER-SDK client libraries. Both of these approaches are compatible with either of the blockchain access setups.

## Setting up Blockchain Access

There are two ways you can set up access to the Everscale blockchain: you may use [Evercloud](https://docs.everos.dev/evernode-platform/products/evercloud/get-started), or set up your own [DApp server](https://docs.everos.dev/evernode-platform/products/dapp-server-ds).

### Using Evercloud

Using [Evercloud](https://docs.everos.dev/evernode-platform/products/evercloud/get-started) allows you to work with Everscale blockchain and the Development Network without having to run your own node. Everdev and SDK can connect to it, as if it were a regular node. It has the same API as a node, and provides all capabilities required for running an exchange.

This page lists the [cloud endpoints](https://docs.everos.dev/ever-sdk/reference/ever-os-api/networks). To get access credentials go through this [guide](https://docs.everos.dev/evernode-platform/products/evercloud/get-started).

Whenever you have to specify a network endpoint in the examples given below, use the endpoints and credentials you receive in the [Evercloud dashboard](https://dashboard.evercloud.dev/projects).

{% hint style="info" %}
Note: We highly recommend testing out the full setup on the developer network first.
{% endhint %}

### Using DApp Server&#x20;

If you prefer to run your own node, you may set up your own [DApp server](https://docs.everos.dev/evernode-platform/products/dapp-server-ds). It is a client node, that may be set up on your own servers and provide full access to either Everscale or the Developer network. To connect to it with Everdev or SDK, it needs to have a domain name and a DNS record. You can specify its URL whenever you have to set the network in the examples given below.

Get the setup scripts in this repository: [https://github.com/tonlabs/evernode-ds](https://github.com/tonlabs/evernode-ds)

#### 1. System Requirements&#x20;

| Configuration | CPU (cores) | RAM (GiB) | Storage (GiB) | Network (Gbit/s) |
| ------------- | ----------- | --------- | ------------- | ---------------- |
| Recommended   | 24          | 128       | 2000          | 1                |

SSD disks are recommended for storage.



#### 2. Prerequisites&#x20;

**2.1 Set the Environment**&#x20;

Set the network in `/scripts/env.sh`: use `main.ton.dev` for the main network and `net.ton.dev` for the developer network. You can also specify notification email.

{% hint style="info" %}
**Note**: We highly recommend testing out the full setup on the developer network first.&#x20;
{% endhint %}

```shell
$ cd  ./scripts/
$ . ./env.sh 
```

#### 2.2 Install Dependencies&#x20;

Ubuntu 20.04:

```shell
$ ./install_deps.sh
```

**Note**: Make sure to add your user to the docker group, or run subsequent command as superuser:

```shell
sudo usermod -a -G docker $USER
```

#### 2.3 Deploy Full Node

Deploy full node:

```shell
$ ./deploy.sh 2>&1 | tee ./deploy.log
```

**Note**: the log generated by this command will be located in the `evernode-ds/scripts/` folder and can be useful for troubleshooting.

## Setting up Deposit Account&#x20;

Currently we can recommend the formally verified [SafeMultisig](https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity/safemultisig) contract for use in deposit accounts. It is well tested and secure, supports multiple custodians, and can be set up to require several independent signatures for any transfers. However it has certain limitations, that may prove problematic for exchanges: it is not possible to send tokens transfers in batches to multiple addresses.

If this functionality is required, you can develop a contract with the needed capabilities or get one developed by someone in the Everscale community.

### Using command line tool&#x20;

[Everdev](https://docs.everos.dev/everdev/), the command line tool for development on the Everscale blockchain, allows to deploy any smart contracts to the blockchain, call all contract methods, sign transactions, and generally manage an account.

It supports the Evercloud and DApp server-based approaches both.

#### 1. Install Everdev&#x20;

```sh
$ npm install -g everdev
```

It requires [NPM](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) to be installed.

If you experience any problems with installation, check out our [troubleshooting](https://docs.everos.dev/everdev/troubleshooting) section.

#### 2. Configure network connection&#x20;

Everdev has a built-in [network](https://docs.everos.dev/everdev/command-line-interface/network-tool) tool to manage your networks and access credentials.

* Evercloud endpoints for mainnet and devnet are already configured by default.
* If you are setting up a connection via your own DApp server, user the following command to add it to the network list.

```shell
everdev network add dappserver <your_dapp_server_url>
```

To set your target network as default (so you will not have to specify it in further steps), use the following command:

```sh
everdev network default network_name
```

#### 3. Set credentials (only for Evercloud)

If you plan to use [Evercloud](add\_to\_exchange.md#using-evercloud) (devnet or mainnet), you need to configure authorization credentials.

Go to your Evercloud [dashboard](https://dashboard.evercloud.dev/), find your "Project Id" and "Secret" (optional) on the "Security" tab, and pass them as parameters:

```sh
everdev network credentials network_name --project <Project Id> --access-key <Secret>
```

Example for mainnet:

```
everdev network credentials main --project 01234567890123456789012345678901 --access-key 98765432109876543210987654321098
```

If are using your own DApp Server, skip this step.

#### 4. Set a giver contract on your network

On Everscale, you need to sponsor a contract address in advance to be able to deploy the contract.

Everdev provides a way to set an account of your choice as a giver for deployment operations, so you will not have to do a separate step of sending tokens to a new contract address every time you deploy something. This contract can be a multisig you own, for example your [Surf](https://ever.surf/) account.

**Note**: To work automatically, the giver contract should have only one custodian.

To set it up, first save the custodian keys of your giver account into a signer that will be used to sign giver transactions (Learn more about the signer tool [here](https://docs.everos.dev/everdev/command-line-interface/signer-tool)):

```sh
everdev signer add giver_sign signer_secret_key_or_seed_phrase_in_quotes
```

Then add the giver address specifying the signer to be used with it.

```sh
everdev network giver network_name giver_address --signer giver_sign --type giver_type
```

Where

`giver_type` us the type of the giver contract you selected (GiverV1 | GiverV2 | GiverV3 | SafeMultisigWallet | SetcodeMultisigWallet)

#### 5. Get deposit account contract files&#x20;

To use the recommended SafeMultisig, get the contract files:

**.tvc** - Compiled contract code

SafeMultisigWallet.tvc direct link:

{% embed url="https://github.com/tonlabs/ton-labs-contracts/raw/master/solidity/safemultisig/SafeMultisigWallet.tvc" %}

**.abi.json** - application binary interface, describing the functions of the contract

SafeMultisigWallet.abi.json direct link:

{% embed url="https://raw.githubusercontent.com/tonlabs/ton-labs-contracts/master/solidity/safemultisig/SafeMultisigWallet.abi.json" %}

Execute the commands of the following steps from the directory with the contract files.

#### 6. Create deposit account signer&#x20;

To generate your deposit account signer enter the following command:

```shell
everdev signer generate deposit_signer
```

To deploy multisig deposit account you will need to specify the public key of the signer. To view it, use the following command:

```sh
everdev signer info deposit_signer
```

The keys will be displayed in terminal:

```sh
{
    "name": "deposit_signer",
    "description": "",
    "keys": {
        "public": "8f8779e7c1944b133a423df96d06ae770c996f19d63438dbf2f569a29529b248",
        "secret": "ce57d2666d0d2c737a03ca4e6cfa38c5ca088dbcef43eb0353896feca8aea2a5"
    }
}

```

Usually a single owner (with a single signer) per deposit account is optimal for any tasks that require automation. However, it is possible to set up accounts with multiple owners. In this case, each of the owners has to generate their own signer and provide their public keys to the deployer. Also, the signer used to deploy the account doesn't have to be among its owners.

#### 7. Deploy the deposit account contract to blockchain

Use the following command for a simple one-owner account:

```shell
everdev contract deploy SafeMultisigWallet.abi.json constructor --signer deposit_signer --input owners:[<owner_public_key>],reqConfirms:1 --value 1000000000
```

Where&#x20;

`value` parameter is the amount of nanotokens to be spent on deployment (can be omitted, in which case 10 tokens from giver will be spent)

`owner_public_key` is usually [the public key](add\_to\_exchange.md#6.-create-deposit-account-signer) of `deposit_signer` in the form `0x...`.

Example:

{% code overflow="wrap" %}
```sh
everdev contract deploy SafeMultisigWallet.abi.json constructor --signer deposit_signer --input owners:[0x8f8779e7c1944b133a423df96d06ae770c996f19d63438dbf2f569a29529b248],reqConfirms:1 --value 1000000000
```
{% endcode %}

For more complex cases (multiple owners etc.) view Everdev contract tool [docs](https://docs.everos.dev/everdev/command-line-interface/contract-management) and [guides](https://docs.everos.dev/everdev/guides/work-with-contracts).

Once the contract is deployed, its address will be displayed in terminal.

```sh
everdev contract deploy SafeMultisigWallet.abi.json constructor --signer deposit_signer --input owners:[0x3da1909b7a4bd11fd9a1d79ca9713a9a8645880e0a7a12f9691c68e95d56fe75],reqConfirms:1 --value 10000000000

Configuration

  Network: dev (devnet.evercloud.dev)
  Signer:  deposit_signer (public 8f8779e7c1944b133a423df96d06ae770c996f19d63438dbf2f569a29529b248)

Address:   0:95c35b94e98c1b5c7716a9129ed5bb0798c8c336465fd8d1eb0d385e3d969494 (calculated from TVC and signer public)

Parameters of constructor:

  owners (uint256[]): ["0x3da1909b7a4bd11fd9a1d79ca9713a9a8645880e0a7a12f9691c68e95d56fe75"]
  reqConfirms (uint8): "1"

Deploying...
Contract is deployed at address: 0:95c35b94e98c1b5c7716a9129ed5bb0798c8c336465fd8d1eb0d385e3d969494

```

### Using SDK&#x20;

You may integrate above described process of deposit account deployment into your exchange backend. The functionality is supported in SDK.

A sample is available in [this repository](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) and an overview is given below.

{% hint style="info" %}
[Bindings](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) for a large number of languages have been developed for SDK.&#x20;
{% endhint %}

Note, that similar to the Everdev approach described above, you have to sponsor a deposit account before deploying contract code. The sample requires you to input the data for a preexisting multisig account on the developer network to server as a giver.

The recommended [SafeMultisig](https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity/safemultisig) contract is used.

```javascript

 async function main(client) {
    // Сonfigures the specified multisig wallet as a wallet to sponsor deploy operation
    const giver = await ensureGiver(client);

    // Generate a key pair for a wallet that we will deploy
    console.log("Generate new wallet keys");
    const walletKeys = await client.crypto.generate_random_sign_keys();

    // In this example we will deploy safeMultisig wallet.
    // Read about it here https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity/safemultisig

    // The first step - initialize new account object with ABI,
    // target network (client) and previously generated key pair (signer) and 
    // calculate future wallet address so that we can sponsor it before deploy.
    // Read more about deploy and other basic concepts here https://everos.dev/faq/blockchain-basic
    const wallet = await getAccount(client, SafeMultisigContract, signerKeys(walletKeys));

    // Save last master block seq_no before we send the first transaction.
    // It will be used later as starting point for pagination request.
    const lastSeqNo = await getLastMasterBlockSeqNo(client);

    // Prepay contract before deploy.
    console.log(`Sending deploy fee from giver wallet ${giver.address} to the new account at ${wallet.address}`);
    await depositAccount(wallet.address, 500_000_000, client);

    console.log(`Deploying new wallet at ${wallet.address}`);
    // Now lets deploy safeMultisig wallet
    // Here we specify 1 custodian and 1 reqConfirms
    // but in real life there can be many custodians as well and more than 1 required confirmations
    await deployAccount(wallet,  {
        owners: [`0x${walletKeys.public}`], // constructor parameters of multisig
        reqConfirms: 1,
    });

    // Lets make a deposit
    console.log("Depositing 2 tokens...");
    await depositAccount(wallet.address, 2_000_000_000, client);

  
 /**
 * Initializes Giver Account that will be used to topup other accounts before deploy.
 *
 * SafeMultisig wallet is used. If you want to use another contract as Giver -
 * read more about how to add a contract to a project here
 * https://docs.everos.dev/ever-sdk/guides/work_with_contracts/add_contract_to_your_app
 */
async function ensureGiver(client) {
    if (_giver) {
        return _giver;
    }
    const address = process.argv[2];
    const secret = process.argv[3];
    if (!address || !secret) {
        console.log("USE: node index <giver-address> <giver-secret-key>");
        console.log("Giver must be a multisig wallet");
        process.exit(1);
    }
    _giver = await getAccount(
        client,
        SafeMultisigContract,
        signerKeys({
            public: (await client.crypto.nacl_sign_keypair_from_secret_key({ secret }))
                .secret.substr(64),
            secret,
        }),
    );
    _giver.address = address;
    return _giver;
}
    
async function getAccount(client, contract, signer) {
    const abi = abiContract(contract.abi);

    // Let's create deploy message to calculate future contract address
    // We do not use `call_set` parameter here because it does not affect address calculation
    const address = (await client.abi.encode_message({
        abi,
        signer: signer,
        deploy_set: {
            tvc: contract.tvc,
        },
    })).address;
    return {
        client,
        address,
        abi,
        tvc: contract.tvc,
        signer,
    };
}

async function getLastMasterBlockSeqNo(client) {
    return (await client.net.query({
        query: `
            query{
              blockchain{
                blocks(workchain:-1, last:1 ){
                  edges{
                    node{
                      seq_no
                    }
                  }
                }
              }
            }
        `
    })).result.data.blockchain.blocks.edges[0].node.seq_no
}

/**
 * Topup an account for deploy operation.
 *
 * We need an account which can be used to deposit other accounts.
 * We call it "giver".
 *
 * This sample uses already deployed multisig wallet with positive balance as a giver.
 *
 * In production you can use any other contract that can transfer funds, as a giver.
 */
async function depositAccount(address, amount, client) {
    return await walletSend(await ensureGiver(client), address, amount);
}

/**
 * Sends some tokens from msig wallet to specified address.
 */
async function walletSend(wallet, address, amount) {
    return await runAndWaitForRecipientTransactions(wallet, "sendTransaction", {
        dest: address,
        value: amount,
        bounce: false,
        flags: 1,
        payload: "",
    });
}

async function runAndWaitForRecipientTransactions(account, functionName, input) {
    const runResult = await account.client.processing.process_message({
        message_encode_params: {
            address: account.address,
            abi: account.abi,
            signer: account.signer,
            call_set: {
                function_name: functionName,
                input,
            },
        },
        send_events: false,
    });

    const transactions = [];

    // This step is only required if you want to know when the recipient actually receives their tokens.
    // In Everscale blockchain, transfer consists of 2 transactions (because the blockchain is asynchronous):
    //  1. Sender sends tokens - this transaction is returned by `Run` method
    //  2. Recipient receives tokens - this transaction can be caught with `query_transaction_tree method`
    // Read more about transactions and messages here
    // https://everos.dev/faq/blockchain-basic
    let countCallingApi = 0;
    while(transactions.length === 0 && countCallingApi < 100) {
        for (const messageId of runResult.transaction.out_msgs) {
            const tree = await account.client.net.query_transaction_tree({
                in_msg: messageId,
            });
            transactions.push(...tree.transactions);
            if (countCallingApi++) {
                await sleep(200); // don't spam API
            }
        }
    }
    return transactions;
}


async function deployAccount(
    account,
    constructorInput,
) {
    return await account.client.processing.process_message({
        message_encode_params: {
            abi: account.abi,
            signer: account.signer,
            deploy_set: {
                tvc: account.tvc,
            },
            call_set: {
                function_name: "constructor",
                input: constructorInput,
            },
        },
        send_events: false,
    });
}
```



## Monitoring Deposit Account&#x20;

An exchange needs to reliably know when customers deposit funds into its exchange accounts. This functionality has been integrated into SDK. A sample is available in [this repository](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) and an overview of the relevant part is given below.

In this sample JS SDK is used. [Bindings](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) for a large number of languages have been developed for SDK.&#x20;

The script iterates over all blocks since the specified time and looks for transfers according to the set up filters. Transfers may be filtered by one or all accounts.

```javascript
    ...
   // To build a query with pagination, let's limit the count of transactions
    // which will be obtained by one request
    const countLimit = 10;

    // And here we retrieve all the wallet's transactions since the specified block seq_no
    // Due to blockchain multi-sharded nature its data needs some time to reach consistency
    // for reliable pagination. This is why we use `for` here, waiting for the last transaction
    // in the list
    let size = 0;
    console.log(`\nTransactions for ${wallet.address} account since block(seq_no):${lastSeqNo}`);
    for await (let transactions of queryAccountTransactions(client, wallet.address, {seq_no: lastSeqNo, count: countLimit})) {
        transactions.forEach(printTransfers);
        size += transactions.length;
        if (size >= 4) {
            // Wait 4 transactions:
            //   1. Sending deploy fee
            //   2. Deploying new wallet
            //   3. Depositing 2 tokens
            //   4. Withdrawing 1 token
            break;
        }
    }
    
    // Now let's iterate all blockchain transactions with value transfers.
    // 
    // Attention! If you try to get the latest master seq_no for `now` you may receive `null` because 
    // the database is not yet consistent. So you can desrease timestamp by, say 30 seconds, or wait in a cycle until 
    // your request returns positive value. 
    // We will iterate data starting from master seq_no which was generated 10 minutes ago.

    const afterSeqNo = await getLastMasterBlockSeqNoByTime(client, seconds(Date.now() - 10*60*1000));
    console.log(`\nTransactions of all accounts`);
    for await (let transactions of queryAllTransactions(client, {seq_no: afterSeqNo, count: countLimit})) {
        // Trying get next trnsactions which contain any valuable transfers
        if (!hasTransfersOnTransactions(transactions)) {
            continue;
        }

        transactions.forEach(printTransfers);

        try {
            await keyPress();
        } catch(_) {
            // If pressed Ctrl+C exits from iteration
            break;
        }
    }
}

async function getLastMasterBlockSeqNoByTime(client, utime) {
return (await client.net.query({
    query: `query MyQuery($utime: Int){
        blockchain {
            master_seq_no_range(time_end: $utime) { end }
        }
    }`,
    variables: {utime},
})).result.data.blockchain.master_seq_no_range.end
}


/**
 * Iterator to query account transactions by using cursor-based pagination.
 */
async function *queryAccountTransactions(
    client,
    address,
    options,
) {
    const variables = {
        address,
        cursor: null,
        ...options,
    }
    for (;;) { // <-- !WARNING! Infinity loop, you need to implement condition to exit from iterator
        const { result } = await client.net.query({query: queryAccount, variables});
        const { transactions } = result.data.blockchain.account;

        yield transactions.edges.map(_ => _.node);
        variables.cursor = transactions.pageInfo.endCursor || variables.cursor;
        await sleep(200); // don't spam API
    }
}

/**
 * Iterator to query ALL blockchain transactions by using cursor-based pagination.
 */
async function *queryAllTransactions(
    client,
    options,
) {
    const variables = {
        cursor: null,
        ...options,
    }
    for (;;) { // <-- !WARNING! Infinity loop, you need to implement condition to exit from iterator
        consoleWrite(`Requesting transactions...`)
        const { result } = await client.net.query({query: queryAll, variables});
        const { transactions } = result.data.blockchain;
        consoleClear()
        yield transactions.edges.map(_ => _.node);
        variables.cursor = transactions.pageInfo.endCursor || variables.cursor;
        await sleep(200); // don't spam API
    }
}


// This API has additional consistency checks to ensure consistent pagination, which can lead to additional delay
const queryAccount = `query MyQuery($address: String!, $cursor: String, $count: Int, $seq_no: Int) {
    blockchain {
        account(address: $address){
            transactions(
                master_seq_no_range: {
                    start: $seq_no
                }
                first: $count
                after: $cursor
            ){
                edges{
                    node{
                        ${TRANSACTION_FIELDS}
                    }
                }
                pageInfo{
                    endCursor
                }
            }
        }
    }
}`;

// This API has additional consistency checks to ensure consistent pagination, which can lead to additional delay
const queryAll = `query MyQuery($cursor: String, $count: Int, $seq_no: Int) {
    blockchain {
        transactions(
            master_seq_no_range: {
                start: $seq_no
            }
            first: $count
            after: $cursor
        ){
            edges{
                node{
                    ${TRANSACTION_FIELDS}
                }
            }
            pageInfo{
                endCursor
            }
        }
    }
}`;
```

You may test out the demo application running this process on the developer network by cloning the [sdk-samples](https://github.com/tonlabs/sdk-samples) repository, and running the following commands in the /demo/exchange folder

```shell
npm i
node index giverAddress giverPrivateKey
```

Read more about giverAddress and giverPrivateKey parameters in the sample [readme](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange).&#x20;

## Withdrawing from deposit accounts&#x20;

The specific function that is used to send the funds to the user depends on the contract chosen for the deposit account. Examples provided below are applicable for the [SafeMultisig](https://github.com/vtchemodanov/tondev/blob/patch-2/docs/deploy\_mulisig\_tondev.md) contract.

### Using command line tool

Command line Everdev tool may be used to implement withdrawals from deposit account.

The simplest way that bypasses any verification and places all risks entirely on the user is to send the full requested amount with a single transfer to the specified address. If the user made a mistake in the address, and has no control over it, these funds will be lost. If the account does not exist, and the user makes mistakes deploying it after the funds are transferred, they may end up being lost as well.

To perform a simple transfer to any account, whether it already exists or not, use the following everdev command:

{% code overflow="wrap" %}
```shell
everdev contract run SafeMultisigWallet.abi.json submitTransaction --signer deposit_signer --input dest:recipient_address,value:500000000,bounce:false,allBalce:false,payload:""
```
{% endcode %}

`deposit_signer` - name of the deposit account owner signer

`recipient_address` - raw address of the recipient smart contract. Example: 255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3

`value`: - amount of tokens to transfer in nanotokens (Example: value:10000000000 sets up a transfer of 10 tokens).

`bounce` - use false to transfer funds to any account regardless of whether it exists.

`payload` - use "" for simple transfer.

`allBalance` - used to transfer all funds in the wallet. Use false for a simple transfer.

{% hint style="info" %}
**Note**: Due to a bug setting `allBalance` to `true` currently causes errors. Single-custodian multisig wallets may use `sendTransaction` method with flag `130` and value `0` instead
{% endhint %}

{% code overflow="wrap" %}
```shell
everdev contract run SafeMultisigWallet.abi.json sendTransaction --signer deposit_signer --input dest:recipient_address,value:0,bounce:false,flags:130,payload:""
```
{% endcode %}

Example of regular withdrawal transaction on a single-owner multisig:

```shell
everdev contract run SafeMultisigWallet.abi.json submitTransaction --signer deposit_signer --input dest:665a62042aff317ba3f32e36b712b0f4a9d35277dd76dc38c9762cc6421681cf,value:500000000000,bounce:false,allBalance:false,payload:""

Configuration

  Network: dev (devnet.evercloud.dev)
  Signer:  deposit_sign (public 3da1909b7a4bd11fd9a1d79ca9713a9a8645880e0a7a12f9691c68e95d56fe75)

Address:   0:95c35b94e98c1b5c7716a9129ed5bb0798c8c336465fd8d1eb0d385e3d969494

Parameters of submitTransaction:

  dest (address): "665a62042aff317ba3f32e36b712b0f4a9d35277dd76dc38c9762cc6421681cf"
  value (uint128): "500000000000"
  bounce (bool): "false"
  allBalance (bool): "false"
  payload (cell): ""

Running...

Execution has finished with result:
{
    "transaction": {
        "json_version": 8,
        "id": "cbeb7f8b1aa7ac89439d9c6772b699a7c042215cef090f206ecc8b21bb230fc9",
        "boc": "te6ccgECDwEAArcAA7d5XDW5TpjBtcdxapEp7VuweYyMM2Rl/Y0esNOF49lpSUAAAOakEwMsEkhiumuyPgwNDWXdmNBHsr9g6Y6XgsntCG/AQxbMH/mAAADmo/0T8BZCW1XwAFSAICQ36AUEAQIPDE/GHimDxEADAgBvyY9CQExRYUAAAAAAAAQAAAAAAARz+2ts0g+y9Ais9VbZ65O+4BourUTTYoPq+tvoLxFJpECQJNQAnUZPYxOIAAAAAAAAAABYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAgnI1Aq0GL7DtfZycdkRDzfxJtFk47dtGidJveUmyV1aRWS0JxA5UCIBaO/paLFUAjm0/YFLGbVz5bUyQ5fEsfxqwAgHgCwYCAd0JBwEBIAgAdeAErhrcp0xg2uO4tUiU9q3YPMZGGbIy/saPWGnC8ey0pKAAABzUgmBlhshLar5JjsFmgAAAAAAAAABAAQEgCgCzSAErhrcp0xg2uO4tUiU9q3YPMZGGbIy/saPWGnC8ey0pKQAZlpiBCr/MXuj8y42txKw9KnTUnfddtw4yXYsxkIWgc9XRqUogAAYUWGAAABzUgmBlhMhLar5AAUWIASuGtynTGDa47i1SJT2rdg8xkYZsjL+xo9YacLx7LSkoDAwB4fRRR+puAACR3O0hyRMPrwVnVPX+pw1OSY/hvAY+6jc/0ST0CDjZIS4ccsC4fPFe5CZoyAH4UOealyQ5K/a8zQXPaGQm3pL0R/ZodecqXE6moZFiA4KehL5aRxo6V1W/nUAAAGHM0x8YGQltYcTHYLNgDQFjgAzLTECFX+YvdH5lxtbiVh6VOmpO+67bhxkuxZjIQtA54AAAAAAAAAAAAAAOjUpRAAQOAAA=",
        "status": 3,
        "status_name": "finalized",
        "storage": {
            "storage_fees_collected": "0x3f",
            "status_change": 0,
            "status_change_name": "unchanged"
        },
        "compute": {
            "success": true,
            "msg_state_used": false,
            "account_activated": false,
            "gas_fees": "0xc53078",
            "gas_used": 12923,
            "gas_limit": 0,
            "gas_credit": 10000,
            "mode": 0,
            "exit_code": 0,
            "vm_steps": 352,
            "vm_init_state_hash": "0000000000000000000000000000000000000000000000000000000000000000",
            "vm_final_state_hash": "0000000000000000000000000000000000000000000000000000000000000000",
            "compute_type": 1,
            "compute_type_name": "vm"
        },
        "action": {
            "success": true,
            "valid": true,
            "no_funds": false,
            "status_change": 0,
            "total_fwd_fees": "0x1e8480",
            "total_action_fees": "0x145850",
            "result_code": 0,
            "tot_actions": 2,
            "spec_actions": 0,
            "skipped_actions": 0,
            "msgs_created": 2,
            "action_list_hash": "39fdb5b66907d97a04567aab6cf5c9df700d1756a269b141f57d6df41788a4d2",
            "tot_msg_size_cells": 2,
            "tot_msg_size_bits": 1178
        },
        "credit_first": true,
        "aborted": false,
        "destroyed": false,
        "tr_type": 0,
        "tr_type_name": "ordinary",
        "lt": "0xe6a413032c1",
        "prev_trans_hash": "24862ba6bb23e0c0d0d65dd98d047b2bf60e98e9782c9ed086fc04316cc1ff98",
        "prev_trans_lt": "0xe6a3fd13f01",
        "now": 1680192863,
        "outmsg_cnt": 2,
        "orig_status": 1,
        "orig_status_name": "Active",
        "end_status": 1,
        "end_status_name": "Active",
        "in_msg": "b10b0866cb7320f9abac1ba6c5a09f7a60bb87b399142aa0a7dda28b086d9a40",
        "ext_in_msg_fee": "0x2798b8",
        "out_msgs": [
            "ff491002eaeaf22e85055d5b055383d8aaaa030bcb5ae34a65b27f15de8e2e34",
            "8f2f48998b041adbae47a3e8ee7541ee918299d316e07c7dbd221501a31b15d8"
        ],
        "account_addr": "0:95c35b94e98c1b5c7716a9129ed5bb0798c8c336465fd8d1eb0d385e3d969494",
        "workchain_id": 0,
        "total_fees": "0x10121bf",
        "balance_delta": "-0x746b5dd5ef",
        "old_hash": "3502ad062fb0ed7d9c9c764443cdfc49b45938eddb4689d26f7949b257569159",
        "new_hash": "2d09c40e5408805a3bfa5a2c55008e6d3f6052c66d5cf96d4c90e5f12c7f1ab0"
    },
    "output": {
        "transId": "0"
    },
    "out_messages": [
        null
    ]
}

```

Basic checks of the address format will be performed by the Everdev utility automatically, only addresses of a valid Everscale format will be accepted.

Note, that if your deposit account has multiple custodians, the transaction has to be confirmed by the required number of signatures to be executed. This transaction ID should be communicated to other custodians, who should use it to confirm the transaction.&#x20;

#### (Optional) Confirm transaction&#x20;

To confirm a transaction, use the following command:

{% code overflow="wrap" %}
```shell
everdev contract run SafeMultisigWallet.abi.json confirmTransaction --signer deposit_signer2 --input transactionId:6954030467099431873
```
{% endcode %}

`deposit_signer2` - signer of another multisig custodian (not the one who initiated the transaction).

`transactionId` – the ID of the transaction can be acquired from the custodian who created it.

See [this guide](https://docs.everos.dev/everdev/guides/work-with-contracts#calling-the-contract-on-chain-and-off-chain) for details on working with multiple custodians.

#### Mitigating risks of token loss due to user error

The are two main cases regarding transfers to user accounts: a user may already have an active account to which they want to withdraw funds, or they may want to withdraw funds to a completely new account, that doesn't exist at the time withdraw is requested.

The status of the account provided by the user may be checked with the following Everdev command:

```shell
everdev contract info --address external_address
```

Example of existing account:

```shell
everdev contract info --address 0:665a62042aff317ba3f32e36b712b0f4a9d35277dd76dc38c9762cc6421681cf

Configuration

  Network: dev (devnet.evercloud.dev)
  Signer:  owner_keys (public 5ff6b5ba62b52b25ef347984912937bffaf2df88605e4e56cb64b9b617a28fea)

Address:   0:665a62042aff317ba3f32e36b712b0f4a9d35277dd76dc38c9762cc6421681cf
Account:   Active
Balance:   ≈ 51655 tokens (51655086754193 nano)
```

Example of account that doesn't exist yet:

```shell
everdev contract info --address 0:6238e23f6987883b3d1a86e1c39c63ae2baf7f93603d0ea5dc9b6e91ef54a1ab

Configuration

  Network: dev (devnet.evercloud.dev)
  Signer:  owner_keys (public 5ff6b5ba62b52b25ef347984912937bffaf2df88605e4e56cb64b9b617a28fea)

Address:   0:6238e23f6987883b3d1a86e1c39c63ae2baf7f93603d0ea5dc9b6e91ef54a1ab (calculated from TVC and signer public)
Code Hash: 80d6c47c4a25543c9b397b71716f3fae1e2c5d247174c52e2c19bd896442b105 (from TVC file)
Account:   Doesn't exist

```

The possible results of this command are the following:

`Doesn't exist` - account does not exist. It needs to be sponsored, then deployed, and only then will it be active.

`Uninit` - account already has some funds on it but contract code has not been deployed yet. User needs to deploy it.

`Active` - account already exists, and its code is deployed.

In the first to cases, the exchange might first transfer a small portion of the requested amount (\~1 EVER) and request that the user deploys their contract. Upon the user's confirmation that the account is deployed, its status may be rechecked, and if it became active, the remaining amount of requested funds may be safely transferred.

If the account is already active, a small portion of the requested amount may be transferred to the user, and the user may be asked what amount they received (note: a small amount of the transfer, usually less than 0.05 EVER, will be spent on fees, so it's best to ask for the whole number of tokens transferred). If the amounts match, the rest of the requested funds may be transferred as well.

#### PIN code verification&#x20;

Additionally, for users that use the [Surf](https://ever.surf/) app to store their tokens, PIN code verification is possible.

For now this method requires using the [TONOS-CLI](https://docs.everos.dev/everdev/command-line-interface/tonos-cli) command line tool.&#x20;

To install it, use the following command:

```sh
everdev tonos-cli install
```

If you use Evercloud, configure [access](add\_to\_exchange.md#using-evercloud):

```sh
tonos-cli config --project_id <evercloud_project_id> --access_key <evercloud_secret>
```

TONOS-CLI may be used to send a transaction with an encrypted PIN code, which the user will be able to see in Surf:

```shell
tonos-cli multisig send --addr <deposit_account_address> --dest <recipient_address> --purpose <"PIN_code"> --sign <path_to_keys_or_seed_phrase> --value *number*js
```

`<deposit_account_address>` - address of the deposit account address that tokens are sent from.

`<recipient_address>` - address of the account tokens are sent to.

`<"PIN_code">` - accompanying message containing the PIN code. Only the recipient will be able to decrypt and read it. should be enclosed in double quotes.

`<path_to_keys_or_seed_phrase>` - path to sender wallet key file of the corresponding seed phrase in quotes.

\-`-value`` `_`number`_ - value to be transferred (**in tokens**).

Example:

```shell
$ tonos-cli multisig send --addr 0:255a3ad9dfa8aa4f3481856aafc7d79f47d50205190bd56147138740e9b177f3 --dest 0:a4629d617df931d8ad86ed24f4cac3d321788ba082574144f5820f2894493fbc --purpose "339" --sign key.json --value 6
Config: /home/user/tonos-cli.conf.json
Connecting to your-endpoint-here
Generating external inbound message...

MessageId: 62b1420ac98e586f29bf79bc2917a0981bb3f15c4757e8dca65370c19146e327
Expire at: Thu, 13 May 2021 13:26:06 +0300
Processing... 
Succeeded.
Result: {
  "transId": "0"
}.
```

### Using SDK&#x20;

You may integrate withdrawals from deposit account into your backend using SDK as well. A sample is available in [this repository](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) and an overview of the relevant part is given below.

In this sample JS SDK is used.  [Bindings](https://github.com/tonlabs/sdk-samples/tree/master/demo/exchange) for a large number of languages have been developed for SDK.&#x20;

This example shows how to generate a withdrawal transaction from a Multisig wallet, using its `sendTransaction` method. Note, that if Multisig has multiple custodians, the transaction will have to be confirmed with the `confirmTransaction` method.

You may choose from which account (sender or recipient), the forward fees will be charged.

In this example tokens are withdrawn from the deposit account to the giver, that initially sponsored it. In a proper implementation, the account given by user should be used instead.

```javascript
/**
 * Withdraws some tokens from Multisig wallet to a specified address.
 *
 * In case of 1 custodian `submitTransaction` method performs full withdraw operation.
 *
 * In case of several custodians, `submitTransaction` creates a transaction inside the wallet
 * for other custodians to confirm.
 * Other custodians need to invoke  `confirmTransaction` method for confirmation.
 * Once enough custodians confirm the transaction it will be withdrawn.
 * Read more how to work with multisig here
 * https://github.com/tonlabs/ton-labs-contracts/tree/master/solidity/safemultisig
 */
async function walletWithdraw(wallet, address, amount) {
    const transactions = await runAndWaitForRecipientTransactions(wallet, "submitTransaction", {
        dest: address,
        value: amount,
        bounce: false,
        allBalance: false,
        payload: "",
    });
    if (transactions.length > 0) {
        console.log(`Recipient received transfer. The recipient's transaction is: ${transactions[0].id}`);
    }
    return transactions
}
```

#### User account verification with SDK&#x20;

Same as described above, users of the [Surf](https://ever.surf/) app can be offered additional verification with a PIN code.

Below is a snippet of the [SDK sample](https://github.com/tonlabs/sdk-samples/tree/master/core-examples/node-js/transfer-with-comment) demonstrating how to generate a transaction with an encrypted comment. A PIN code can be transmitted to the user in this comment attached to a small amount of tokens, and only after the user provides the PIN code, thus proving they have access to their account, may the rest of the withdrawal amount be transferred.

```javascript
// Prepare body with comment
        // For that we need to prepare internal message with transferAbi and then extract body from it
        const body = (await client.abi.encode_message_body({
            abi: abiContract(transferAbi),
            call_set: {
                function_name: "transfer",
                input: {
                    comment: Buffer.from("My comment").toString("hex"),
                },
            },
            is_internal: true,
            signer: signerNone(),
        })).body;

        const multisig = new Account(MultisigContract, {
            signer: signerKeys(keyPair),
            client,
        });

        // Run 'submitTransaction' method of multisig wallet
        // Create run message

        console.log("Call `submitTransaction` function");
        const transactionInfo = (await multisig.run("submitTransaction", {
            dest: recipient,
            value: 100_000_000,
            bounce: false,
            allBalance: false,
            payload: body,
        }));
        console.log(transactionInfo);
        console.log("Transaction info:");

        console.log("Id:");
        console.log(transactionInfo.transaction.id);
        console.log("messages:");
        console.log(transactionInfo.out_messages);
        const messages = transactionInfo.out_messages;

        const decodedMessage1 = (await tonClient.abi.decode_message({
            abi: abiContract(transferAbi),
            message: messages[0],
        }));

        // Decode comment from hex to string
        decodedMessage1.value.comment = Buffer.from(decodedMessage1.value.comment, "hex").toString("utf8");

        console.log("Decoded message 1:", decodedMessage1.value);

        const decodedMessage2 = (await tonClient.abi.decode_message({
            abi: abiContract(multisigContractPackage.abi),
            message: messages[1],
        }));

        console.log("Decoded message 2:", decodedMessage2);
```
